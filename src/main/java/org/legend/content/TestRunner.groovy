//ngrinder脚本的上下文对象


import junit.framework.TestCase
import org.legend.content.bean.Student

import static net.grinder.script.Grinder.grinder

import net.grinder.script.GTest
import net.grinder.scriptengine.groovy.junit.GrinderRunner
import net.grinder.scriptengine.groovy.junit.annotation.BeforeProcess
import net.grinder.scriptengine.groovy.junit.annotation.BeforeThread
// import static net.grinder.util.GrinderUtils.* // You can use this if you're using nGrinder after 3.2.3
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

import org.ngrinder.http.HTTPRequest
import org.ngrinder.http.HTTPRequestControl
import org.ngrinder.http.HTTPResponse
import org.ngrinder.http.cookie.Cookie

/**
 * A simple example using the HTTP plugin that shows the retrieval of a single page via HTTP.
 *
 * This script is automatically generated by ngrinder.
 *
 * @author admin
 */

/**
 * nGrinder中的Groovy测试用例应该用@RunWith(GrinderRunner)注释。
 * 当您在每个IDE的JUnit Runner中运行此脚本时，这部分将使GroovyRunner控制JUnit行为并在JUnit上装载grinder上下文。
 *
 * "nGrinder + Junit结合"
 */
@RunWith(GrinderRunner)//用GrinderRunner测试(扩展了的junit4)
class TestRunner {
//    @Autowired
//    private
    /**
     * 脚本创建测试实例，然后其可以用于包装其他Jython对象
     *
     * 对于nGrinder而言，test是记录统计数据的工作单位。
     * 1.test由测试号唯一定义，并且还可以具体描述
     * 2.脚本可以在同一个测试中报告许多不同类型的东西，nGrinder将汇总结果
     * 3.创建一个Test将自动使用测试号和描述自动，更新nGrinder console。
     * 如果使用相同数量但不同的描述创建两个Test，则console将显示第一个描述
     */
    public static GTest test
    /**
     *
     */
    public static HTTPRequest request
    public static Map<String, String> headers = [:]
    public static Map<String, Object> params = [:]
    public static List<Cookie> cookies = []

    @BeforeProcess
    static void beforeProcess() {
        //设置与远程应用服务器建立连接的时间
        HTTPRequestControl.setConnectionTimeout(30000)
        //创建一个test实例
        test = new GTest(1, "BaiDu")
        //创建一个httpclient的HTTPRequest实例(发送请求)
        request = new HTTPRequest()
        //获取一个slf4j的Logger，并用其记录日志信息
        grinder.logger.info("before process.")
        //为什么grinder接口调用接口方法只需要用属性名，属性名从哪来？？？
        println "进程数：" + grinder.firstProcessNumber
    }

    @BeforeThread
    void beforeThread() {
        //记录目标对象->TestRunner类的实例的test方法的仪表数据
        test.record(this, "test")
        /**
         * 用于延迟向日志和控制台报告上次测试统计信息，以便脚本可以修改它们。
         * 通常，当测试包装的代码完成时，会自动报告测试统计信息。
         * 将此设置为 true 后，将在以下时间报告已完成测试的统计信息：
         * 下一次测试开始时
         * 当封闭测试结束时
         * 当前运行完成时
         * 当脚本调用 report方法
         * 当脚本调用 setDelayReports(false) 时
         */
        grinder.statistics.delayReports = true
        grinder.logger.info("before thread.")
    }

    @Before
    void before() {
        request.setHeaders(headers)
//        CookieManager.addCookies(cookies)
        grinder.logger.info("before. init headers and cookies")
    }

    /**
     * @Test注释的方法可能会重复执行。
     * 如下所示，您可以使用JUnit断言来断言测试结果。如果断言失败，则绑定到此线程的最后一个测试将被评估为失败。
     */
    @Test
     void test() {
//        println SecureUtil.md5("a")//加密转为16进制字符串
        HTTPResponse response = request.GET("http://www.baidu.com", params)

        if (response.statusCode == 301 || response.statusCode == 302) {
            grinder.logger.warn("Warning. The response may not be correct. The response code was {}.", response.statusCode)
        } else {
            Student student = new Student("legend", 36)
            println(student.getName())
            TestCase.assertEquals(response.statusCode, 200)
        }

    }
}
